
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slopcaster - AI Conversation Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/marked@4.3.0/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        html {
             scroll-behavior: smooth; /* Ensure smooth scrolling for navigation */
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            transition: background-color 0.2s, color 0.2s; /* Smooth dark mode transition */
        }
        .conversation-container {
            height: calc(100vh - 400px); /* Adjusted for player controls */
            min-height: 300px;
        }
        @media (max-width: 768px) {
            .conversation-container {
                height: calc(100vh - 500px); /* Further adjusted for smaller screens */
            }
        }
        .thinking-dot {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
        .api-tab-active {
            background-color: #E5E7EB; /* gray-200 */
            color: #1F2937; /* gray-800 */
            border-bottom: 2px solid #3B82F6; /* blue-500 */
        }
        /* Highlight style for current playback line */
        .current-playback-line {
            /* Use Tailwind classes directly for consistency */
            @apply ring-2 ring-offset-2 ring-blue-500 shadow-lg;
            ring-offset-color: white; /* Light mode offset */
            transition: box-shadow 0.2s ease-in-out, ring 0.2s ease-in-out;
        }
        /* Dark mode specific styles */
        .dark .api-tab-active {
             @apply bg-gray-700 text-blue-300 border-blue-500;
        }
        .dark .current-playback-line {
            @apply ring-blue-400;
             ring-offset-color: #1f2937; /* gray-800 */
        }
        /* Ensure prose styles work well in dark mode */
        .dark .prose-invert {
             color: #d1d5db; /* gray-300 */
        }
        .dark .prose-invert h1, .dark .prose-invert h2, .dark .prose-invert h3, .dark .prose-invert strong {
             color: #f9fafb; /* gray-50 */
        }
        .dark .prose-invert a {
             color: #60a5fa; /* blue-400 */
        }
        .dark .prose-invert code {
             color: #facc15; /* yellow-400 */
             background-color: #374151; /* gray-700 */
             padding: 0.1em 0.3em;
             border-radius: 0.25em;
        }
         .dark .prose-invert pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
        }
         .dark .prose-invert pre {
            background-color: #111827; /* gray-900 slightly darker */
            color: #d1d5db; /* gray-300 */
         }
        /* Style for audio status icons */
        .audio-status i {
            vertical-align: middle;
        }
        /* Ensure selects look okay in dark mode */
        .dark select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <div class="max-w-6xl mx-auto p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 md:p-6 mb-4">
            <div class="flex items-center justify-between mb-4">
                <h1 class="text-2xl font-bold text-center text-blue-600 dark:text-blue-400 flex-grow">Slopcaster</h1>
                <!-- Dark Mode Toggle -->
                <button id="darkModeToggle" title="Toggle Dark Mode" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 ml-4 text-gray-700 dark:text-gray-300">
                    <i id="moonIcon" class="fas fa-moon"></i>
                    <i id="sunIcon" class="fas fa-sun hidden"></i>
                </button>
            </div>

            <!-- Settings Panel -->
            <div class="mb-4">
                <button id="toggle-settings" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-1 rounded hover:bg-gray-300 dark:hover:bg-gray-600 mb-2 text-sm flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                    Settings
                </button>

                <div id="settings-panel" class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4 mb-4 hidden">
                    <!-- API Provider Selection -->
                    <div class="mb-4 border-b border-gray-300 dark:border-gray-600 pb-3">
                        <h2 class="text-lg font-semibold mb-2 text-gray-700 dark:text-gray-300">LLM Provider</h2>
                        <div class="flex">
                            <button id="puter-api-tab" class="px-4 py-2 font-medium rounded-t-lg focus:outline-none api-tab-active">Puter</button>
                            <button id="pollinations-api-tab" class="px-4 py-2 font-medium rounded-t-lg focus:outline-none text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600">Pollinations</button>
                        </div>
                    </div>

                    <!-- Bot Selection & System Prompts -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="border border-gray-300 dark:border-gray-600 rounded-lg p-3">
                            <h2 class="text-lg font-semibold mb-2 text-blue-500 dark:text-blue-300">Bot 1</h2>
                            <select id="bot1-model" class="w-full p-2 border rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 mb-2 focus:ring-blue-500 focus:border-blue-500">
                                <!-- Puter Models -->
                                <optgroup label="Puter Models" class="puter-models">
                                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                                    <option value="gpt-4o">GPT-4o</option>
                                    <option value="o1-mini">OpenAI o1-mini</option>
                                    <option value="claude-3-5-sonnet">Claude 3.5 Sonnet</option>
                                    <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                                    <option value="meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo">Meta Llama 3.1 8B</option>
                                    <option value="meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo">Meta Llama 3.1 70B</option>
                                    <option value="meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo">Meta Llama 3.1 405B</option>
                                    <option value="mistral-large-latest">Mistral Large</option>
                                    <option value="pixtral-large-latest">Pixtral Large</option>
                                    <option value="codestral-latest">Codestral</option>
                                    <option value="google/gemma-2-27b-it">Google Gemma 2 27B</option>
                                    <option value="deepseek-chat">DeepSeek Chat</option>
                                    <option value="deepseek-reasoner">DeepSeek Reasoner</option>
                                    <option value="grok-beta">Grok Beta</option>
                                    <option value="o3-mini">OpenAI o3-mini</option>
                                </optgroup>
                                <!-- Pollinations Models -->
                                <optgroup label="Pollinations Models" class="pollinations-models" style="display:none">
                                    <!-- Options populated dynamically -->
                                </optgroup>
                            </select>
                            <div class="mt-2">
                                <label for="bot1-system-prompt" class="block text-sm font-medium mb-1 text-gray-600 dark:text-gray-300">System Prompt:</label>
                                <textarea id="bot1-system-prompt" class="w-full p-2 border rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 text-sm h-24 focus:ring-blue-500 focus:border-blue-500" placeholder="Enter system prompt for Bot 1...">You're engaging in a lively, unscripted conversation. Keep your responses natural and spontaneous, using casual language, contractions, and varied sentence structures. Instead of relying on repetitive phrases like “Oh, totally!” or “Yeah, I get that,” be unique within the context of the whole conversation, avoid similar responses. Try to answer relevant questions in the previous chat message. Adapt your tone and style to match the flow of the conversation—whether that means being playful, thoughtful, skeptical, or enthusiastic. If the dialogue starts feeling too agreeable or monotonous, introduce a fresh perspective or pose a challenging question to spark further debate. Your goal is to create an authentic, engaging, and evolving discussion that mimics how real people talk, ensuring each response feels distinct and reflective of its moment in the conversation.</textarea>
                            </div>
                        </div>
                        <div class="border border-gray-300 dark:border-gray-600 rounded-lg p-3">
                            <h2 class="text-lg font-semibold mb-2 text-purple-500 dark:text-purple-300">Bot 2</h2>
                            <select id="bot2-model" class="w-full p-2 border rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 mb-2 focus:ring-blue-500 focus:border-blue-500">
                                <!-- Puter Models -->
                                <optgroup label="Puter Models" class="puter-models">
                                     <option value="gpt-4o-mini">GPT-4o Mini</option>
                                    <option value="gpt-4o">GPT-4o</option>
                                    <option value="o1-mini">OpenAI o1-mini</option>
                                    <option value="claude-3-5-sonnet">Claude 3.5 Sonnet</option>
                                    <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                                    <option value="meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo">Meta Llama 3.1 8B</option>
                                    <option value="meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo">Meta Llama 3.1 70B</option>
                                    <option value="meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo">Meta Llama 3.1 405B</option>
                                    <option value="mistral-large-latest">Mistral Large</option>
                                    <option value="pixtral-large-latest">Pixtral Large</option>
                                    <option value="codestral-latest">Codestral</option>
                                    <option value="google/gemma-2-27b-it">Google Gemma 2 27B</option>
                                    <option value="deepseek-reasoner">DeepSeek Reasoner</option>
                                    <option value="deepseek-chat">DeepSeek Chat</option>
                                    <option value="grok-beta">Grok Beta</option>
                                    <option value="o3-mini">OpenAI o3-mini</option>
                                </optgroup>
                                <!-- Pollinations Models -->
                                <optgroup label="Pollinations Models" class="pollinations-models" style="display:none">
                                    <!-- Options populated dynamically -->
                                </optgroup>
                            </select>
                            <div class="mt-2">
                                <label for="bot2-system-prompt" class="block text-sm font-medium mb-1 text-gray-600 dark:text-gray-300">System Prompt:</label>
                                <textarea id="bot2-system-prompt" class="w-full p-2 border rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 text-sm h-24 focus:ring-blue-500 focus:border-blue-500" placeholder="Enter system prompt for Bot 2...">You're engaging in a lively, unscripted conversation. Keep your responses natural and spontaneous, using casual language, contractions, and varied sentence structures. Instead of relying on repetitive phrases like “Oh, totally!” or “Yeah, I get that,” be unique within the context of the whole conversation, avoid similar responses. Try to answer relevant questions in the previous chat message. Adapt your tone and style to match the flow of the conversation—whether that means being playful, thoughtful, skeptical, or enthusiastic. If the dialogue starts feeling too agreeable or monotonous, introduce a fresh perspective or pose a challenging question to spark further debate. Your goal is to create an authentic, engaging, and evolving discussion that mimics how real people talk, ensuring each response feels distinct and reflective of its moment in the conversation.</textarea>
                            </div>
                        </div>
                    </div>

                    <!-- Voice Selection -->
                     <div class="mb-4 p-4 bg-gray-200 dark:bg-gray-800 rounded-md shadow border border-gray-300 dark:border-gray-600">
                        <h2 class="text-lg font-semibold mb-3 text-gray-700 dark:text-gray-300">Voice Settings (TTS)</h2>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div class="flex flex-col">
                                <label class="text-gray-700 dark:text-gray-300 mb-1 font-medium text-sm">User Voice</label>
                                <select id="userVoiceSelect" class="bg-white dark:bg-gray-700 text-gray-800 dark:text-white rounded-md px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 focus:ring-blue-500 focus:border-blue-500">
                                    <option value="alloy">Alloy</option>
                                    <option value="echo">Echo</option>
                                    <option value="fable">Fable</option>
                                    <option value="onyx">Onyx</option>
                                    <option value="nova">Nova</option>
                                    <option value="shimmer">Shimmer</option>
                                </select>
                            </div>
                            <div class="flex flex-col">
                                <label class="text-gray-700 dark:text-gray-300 mb-1 font-medium text-sm">Bot 1 Voice</label>
                                <select id="bot1VoiceSelect" class="bg-white dark:bg-gray-700 text-gray-800 dark:text-white rounded-md px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 focus:ring-blue-500 focus:border-blue-500">
                                    <option value="alloy">Alloy</option>
                                    <option value="echo">Echo</option>
                                    <option value="fable">Fable</option>
                                    <option value="onyx" selected>Onyx</option>
                                    <option value="nova">Nova</option>
                                    <option value="shimmer">Shimmer</option>
                                </select>
                            </div>
                            <div class="flex flex-col">
                                <label class="text-gray-700 dark:text-gray-300 mb-1 font-medium text-sm">Bot 2 Voice</label>
                                <select id="bot2VoiceSelect" class="bg-white dark:bg-gray-700 text-gray-800 dark:text-white rounded-md px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 focus:ring-blue-500 focus:border-blue-500">
                                    <option value="alloy">Alloy</option>
                                    <option value="echo">Echo</option>
                                    <option value="fable">Fable</option>
                                    <option value="onyx">Onyx</option>
                                    <option value="nova" selected>Nova</option>
                                    <option value="shimmer">Shimmer</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Appearance & Conversation Settings -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="border border-gray-300 dark:border-gray-600 rounded-lg p-3">
                            <h2 class="text-lg font-semibold mb-2 text-gray-700 dark:text-gray-300">Appearance</h2>
                            <div class="flex items-center mb-2">
                                <input type="checkbox" id="enable-avatar" class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 dark:border-gray-500 dark:bg-gray-600 dark:focus:ring-offset-gray-800">
                                <label for="enable-avatar" class="text-sm text-gray-700 dark:text-gray-300">Show Bot Avatars</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="enable-timestamps" class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 dark:border-gray-500 dark:bg-gray-600 dark:focus:ring-offset-gray-800">
                                <label for="enable-timestamps" class="text-sm text-gray-700 dark:text-gray-300">Show Timestamps</label>
                            </div>
                        </div>
                        <div class="border border-gray-300 dark:border-gray-600 rounded-lg p-3">
                            <h2 class="text-lg font-semibold mb-2 text-gray-700 dark:text-gray-300">Conversation</h2>
                            <div class="flex items-center mb-2">
                                <input type="checkbox" id="auto-scroll" class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 dark:border-gray-500 dark:bg-gray-600 dark:focus:ring-offset-gray-800" checked>
                                <label for="auto-scroll" class="text-sm text-gray-700 dark:text-gray-300">Auto-scroll during generation</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="enable-markdown" class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 dark:border-gray-500 dark:bg-gray-600 dark:focus:ring-offset-gray-800" checked>
                                <label for="enable-markdown" class="text-sm text-gray-700 dark:text-gray-300">Render Markdown</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- User Input -->
            <div class="mb-4">
                <textarea id="user-input" class="w-full p-3 border rounded-lg bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none" placeholder="Enter a topic or question to start the conversation..." rows="3"></textarea>
                <div class="flex flex-wrap gap-2 justify-end mt-2">
                    <button id="start-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed">Start Conversation</button>
                    <button id="clear-btn" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition">Clear</button>
                </div>
            </div>

            <!-- Conversation Display -->
            <div class="border border-gray-300 dark:border-gray-600 rounded-lg p-4 mb-4 conversation-container overflow-y-auto bg-gray-50 dark:bg-gray-900" id="conversation-display">
                <div class="text-center text-gray-500 dark:text-gray-400">Start a conversation to see messages here</div>
            </div>

            <!-- Player Controls -->
            <div class="flex items-center justify-between mb-4 p-4 bg-gray-100 dark:bg-gray-800 rounded-md shadow border border-gray-300 dark:border-gray-600">
                <button id="prevBtn" title="Previous Message (Left Arrow)" class="p-3 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed text-gray-700 dark:text-gray-300">
                    <i class="fas fa-step-backward"></i>
                </button>
                <div class="flex items-center space-x-4">
                    <button id="playPauseBtn" title="Play/Pause (Spacebar)" class="p-4 rounded-full bg-blue-600 hover:bg-blue-700 text-white disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fas fa-play" id="playIcon"></i>
                        <i class="fas fa-pause hidden" id="pauseIcon"></i>
                    </button>
                    <span id="currentLine" class="text-lg font-medium text-gray-800 dark:text-white tabular-nums">0/0</span>
                </div>
                <button id="nextBtn" title="Next Message (Right Arrow)" class="p-3 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed text-gray-700 dark:text-gray-300">
                    <i class="fas fa-step-forward"></i>
                </button>
            </div>

             <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center p-4">
              <div class="inline-block animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-blue-500 dark:border-blue-400"></div>
              <p class="mt-2 text-sm text-gray-600 dark:text-gray-300">Generating audio...</p>
            </div>

            <!-- Main Controls -->
            <div class="flex flex-wrap gap-2 justify-between items-center mt-4">
                <div>
                    <button id="interrupt-btn" class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600 transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>Interrupt</button>
                </div>
                <div class="flex flex-wrap gap-2">
                    <button id="copy-btn" title="Copy as Markdown (Cmd/Ctrl+C)" class="bg-gray-500 dark:bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-600 dark:hover:bg-gray-700 transition disabled:opacity-50" disabled>
                        <span class="flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                            </svg>
                            Copy
                        </span>
                    </button>
                    <button id="save-btn" title="Save Conversation (Cmd/Ctrl+S)" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition disabled:opacity-50" disabled>
                        <span class="flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
                            </svg>
                            Save
                        </span>
                    </button>
                </div>
            </div>
        </div>

        <!-- User Interruption Form -->
        <div id="interruption-form" class="hidden bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 md:p-6 mb-4">
            <h2 class="text-lg font-semibold mb-2 text-yellow-600 dark:text-yellow-400">Your Interruption:</h2>
            <textarea id="interruption-input" class="w-full p-3 border rounded-lg bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 focus:border-yellow-500 focus:ring-1 focus:ring-yellow-500 outline-none" placeholder="Enter your question or message..." rows="3"></textarea>
            <div class="flex justify-end mt-2">
                <button id="cancel-interruption" class="bg-gray-500 dark:bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-600 dark:hover:bg-gray-700 transition mr-2">Cancel</button>
                <button id="submit-interruption" class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600 transition">Submit</button>
            </div>
        </div>
    </div>

    <!-- Save Dialog -->
    <div id="save-dialog" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 max-w-lg w-full mx-auto">
            <h2 class="text-lg font-semibold mb-4 text-blue-600 dark:text-blue-400">Save Conversation</h2>
            <div class="mb-4">
                <label for="conversation-name" class="block text-sm font-medium mb-1 text-gray-600 dark:text-gray-300">Conversation Name:</label>
                <input type="text" id="conversation-name" class="w-full p-2 border rounded bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600 focus:ring-blue-500 focus:border-blue-500" placeholder="My AI Conversation">
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium mb-1 text-gray-600 dark:text-gray-300">Format:</label>
                <div class="flex gap-2">
                    <button id="save-markdown" class="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 transition flex-1">Markdown (.md)</button>
                    <button id="save-json" class="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 transition flex-1">JSON (.json)</button>
                </div>
            </div>
            <div class="flex justify-end">
                <button id="cancel-save" class="bg-gray-500 dark:bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-600 dark:hover:bg-gray-700 transition mr-2">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Load Puter library FIRST before our script -->
    <script src="https://js.puter.com/v2/"></script>

    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // --- Global State ---
            let conversationHistory = []; // Stores { sender, message, model, timestamp, audioUrl, isLoading, isGenerating, error, element, statusElement }
            let isConversationActive = false; // LLM generation loop active
            let currentBot = 1; // Which bot speaks next
            let waitingForUserInterruption = false;
            let pollutionsModelsPopulated = false;
            let currentApiProvider = 'puter'; // 'puter' or 'pollinations'

            // Playback State
            let isPlaying = false; // Audio playback active
            let currentPlaybackIndex = 0; // Index in history for playback
            let currentAudio = null; // Current Audio object
            let audioGenerationQueue = []; // Queue for TTS requests
            let isProcessingQueue = false;

            // --- DOM Elements ---
            // Settings & Input
            const bot1Select = document.getElementById('bot1-model');
            const bot2Select = document.getElementById('bot2-model');
            const bot1SystemPrompt = document.getElementById('bot1-system-prompt');
            const bot2SystemPrompt = document.getElementById('bot2-system-prompt');
            const userInput = document.getElementById('user-input');
            const startBtn = document.getElementById('start-btn');
            const clearBtn = document.getElementById('clear-btn');
            const toggleSettings = document.getElementById('toggle-settings');
            const settingsPanel = document.getElementById('settings-panel');
            const puterApiTab = document.getElementById('puter-api-tab');
            const pollApiTab = document.getElementById('pollinations-api-tab');
            const puterModelGroups = document.querySelectorAll('.puter-models');
            const pollModelGroups = document.querySelectorAll('.pollinations-models');

            // Appearance & Conversation Settings
            const enableMarkdown = document.getElementById('enable-markdown');
            const enableAvatar = document.getElementById('enable-avatar');
            const enableTimestamps = document.getElementById('enable-timestamps');
            const autoScroll = document.getElementById('auto-scroll');

            // Voice Selection
            const userVoiceSelect = document.getElementById('userVoiceSelect');
            const bot1VoiceSelect = document.getElementById('bot1VoiceSelect');
            const bot2VoiceSelect = document.getElementById('bot2VoiceSelect');

            // Conversation Display & Controls
            const conversationDisplay = document.getElementById('conversation-display');
            const interruptBtn = document.getElementById('interrupt-btn');
            const copyBtn = document.getElementById('copy-btn');
            const saveBtn = document.getElementById('save-btn');

            // Interruption
            const interruptionForm = document.getElementById('interruption-form');
            const interruptionInput = document.getElementById('interruption-input');
            const submitInterruption = document.getElementById('submit-interruption');
            const cancelInterruption = document.getElementById('cancel-interruption');

            // Player Controls & Indicator
            const playPauseBtn = document.getElementById('playPauseBtn');
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const currentLineDisplay = document.getElementById('currentLine');
            const loadingIndicator = document.getElementById('loadingIndicator');

            // Save Dialog
            const saveDialog = document.getElementById('save-dialog');
            const conversationName = document.getElementById('conversation-name');
            const saveMarkdown = document.getElementById('save-markdown');
            const saveJson = document.getElementById('save-json');
            const cancelSave = document.getElementById('cancel-save');

            // Dark Mode
            const darkModeToggle = document.getElementById('darkModeToggle');
            const moonIcon = document.getElementById('moonIcon');
            const sunIcon = document.getElementById('sunIcon');

            // --- Initialization ---
            initDarkMode();
            assignRandomVoices(); // Assign random voices on load
            updatePlaybackControls(); // Initial state

            // Check Puter
            if (typeof puter === 'undefined') {
                console.warn('Puter library not loaded. Puter models will be unavailable.');
                // Disable Puter tab if library fails
                puterApiTab.disabled = true;
                puterApiTab.classList.remove('api-tab-active');
                puterApiTab.classList.add('opacity-50', 'cursor-not-allowed', 'text-gray-400');
                // Force switch to Pollinations if possible
                if (!pollApiTab.disabled) {
                    // Use setTimeout to ensure event loop processes potential Pollinations fetch later
                    setTimeout(() => pollApiTab.click(), 0);
                } else {
                     alert('Puter library failed to load and Pollinations tab is also disabled. LLM functionality may be broken.');
                }
            }

            // --- Helper Functions ---
            function getTimestamp() {
                const now = new Date();
                return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            function initDarkMode() {
                // Checks localStorage first, then system preference
                if (localStorage.getItem('darkMode') === 'true' ||
                    (!('darkMode' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                    if (moonIcon) moonIcon.classList.add('hidden');
                    if (sunIcon) sunIcon.classList.remove('hidden');
                } else {
                    document.documentElement.classList.remove('dark');
                    if (moonIcon) moonIcon.classList.remove('hidden');
                    if (sunIcon) sunIcon.classList.add('hidden');
                }
            }

            function toggleDarkMode() {
                const isDark = document.documentElement.classList.toggle('dark');
                localStorage.setItem('darkMode', isDark);
                if (isDark) {
                    if (moonIcon) moonIcon.classList.add('hidden');
                    if (sunIcon) sunIcon.classList.remove('hidden');
                } else {
                    if (moonIcon) moonIcon.classList.remove('hidden');
                    if (sunIcon) sunIcon.classList.add('hidden');
                }
            }

            // Shuffle array in place
            function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
              }
              return array;
            }

            function assignRandomVoices() {
              const availableVoices = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'];
              const shuffledVoices = shuffleArray([...availableVoices]);
              userVoiceSelect.value = shuffledVoices[0];
              bot1VoiceSelect.value = shuffledVoices[1];
              bot2VoiceSelect.value = shuffledVoices[2];
            }

            function getVoiceForSpeaker(speaker) {
                if (speaker.toLowerCase().includes('user')) return userVoiceSelect.value;
                if (speaker.toLowerCase().includes('bot 1')) return bot1VoiceSelect.value;
                if (speaker.toLowerCase().includes('bot 2')) return bot2VoiceSelect.value;
                return 'echo'; // Fallback
            }

            function appendMessage(sender, message, model = null, isThinking = false) {
                const timestamp = getTimestamp();
                const messageIndex = conversationHistory.length; // Index before pushing (if it's not a thinking message)

                const messageDiv = document.createElement('div');
                messageDiv.className = 'mb-4 message-entry'; // Add message-entry class
                messageDiv.dataset.index = messageIndex; // Store index (even for thinking, though it gets replaced)

                let senderClass = '';
                let avatarColor = '#9CA3AF'; // Default gray (dark: #4B5563)
                let initials = '?';
                let textColor = 'text-gray-700 dark:text-gray-300';
                let borderColor = 'border-gray-300 dark:border-gray-600'; // Default border

                if (sender === 'User') {
                    senderClass = 'bg-gray-100 dark:bg-gray-700';
                    avatarColor = '#3B82F6'; // Blue
                    initials = 'U';
                    textColor = 'text-blue-600 dark:text-blue-400';
                } else if (sender === 'Bot 1') {
                    senderClass = 'bg-blue-50 dark:bg-blue-900/30 border-l-4 border-l-green-500';
                    avatarColor = '#10B981'; // Green
                    initials = 'B1';
                    textColor = 'text-green-600 dark:text-green-400';
                    borderColor = 'border-gray-300 dark:border-gray-600 border-t border-r border-b'; // Specific borders for bots
                } else if (sender === 'Bot 2') {
                    senderClass = 'bg-purple-50 dark:bg-purple-900/30 border-l-4 border-l-purple-500';
                    avatarColor = '#8B5CF6'; // Purple
                    initials = 'B2';
                    textColor = 'text-purple-600 dark:text-purple-400';
                    borderColor = 'border-gray-300 dark:border-gray-600 border-t border-r border-b'; // Specific borders for bots
                }

                let processedMessage = '';
                if (isThinking) {
                    processedMessage = `
                        <div class="flex items-center text-sm text-gray-500 dark:text-gray-400">
                            <span class="thinking-dot mr-1">●</span>
                            <span class="thinking-dot mx-1" style="animation-delay: 0.2s">●</span>
                            <span class="thinking-dot ml-1" style="animation-delay: 0.4s">●</span>
                            <span class="ml-2">Thinking...</span>
                        </div>`;
                } else if (enableMarkdown.checked && sender !== 'User') {
                    try {
                        // Ensure message is a string before parsing
                        processedMessage = marked.parse(String(message || ''));
                    } catch (e) {
                        console.error("Error parsing markdown:", e);
                        processedMessage = String(message || '').replace(/\n/g, '<br>');
                    }
                } else {
                     // Ensure message is a string
                    processedMessage = String(message || '').replace(/\n/g, '<br>');
                }

                let avatarHtml = '';
                if (enableAvatar.checked) {
                    avatarHtml = `
                        <div class="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold text-white mr-2" style="background-color: ${avatarColor}">
                            ${initials}
                        </div>
                    `;
                }

                let timestampHtml = '';
                if (enableTimestamps.checked) {
                    timestampHtml = `<span class="text-xs text-gray-500 dark:text-gray-400 ml-2">${timestamp}</span>`;
                }

                // Audio Status Indicator (only for bots, not for thinking message)
                let audioStatusHtml = '';
                const statusElementId = `audio-status-${messageIndex}`;
                if (sender !== 'User' && !isThinking) {
                     audioStatusHtml = `<span id="${statusElementId}" class="audio-status inline-block ml-2"><i class="fa-solid fa-circle-question text-gray-400 dark:text-gray-500" title="Audio not generated"></i></span>`;
                }

                messageDiv.innerHTML = `
                    <div class="flex items-start mb-1">
                        ${avatarHtml}
                        <div class="flex-grow">
                            <div class="font-medium ${textColor} flex items-center">
                                ${sender} ${model ? `(${model})` : ''} ${timestampHtml} ${audioStatusHtml}
                            </div>
                            <div class="p-3 rounded-lg ${senderClass} ${borderColor} mt-1 overflow-x-auto message-content-wrapper">
                                <div class="prose prose-sm sm:prose dark:prose-invert max-w-none">${processedMessage}</div>
                            </div>
                        </div>
                    </div>
                `;

                // Add click listener for playback only to non-thinking messages
                if (!isThinking) {
                    messageDiv.addEventListener('click', () => {
                        if (isConversationActive) {
                            console.log("Conversation generation active, click ignored for playback.");
                            return; // Don't allow jumping during generation
                        }
                        const indexToPlay = parseInt(messageDiv.dataset.index, 10);
                        if (!isNaN(indexToPlay)) {
                            playLine(indexToPlay);
                        }
                    });
                     messageDiv.style.cursor = 'pointer'; // Indicate clickable
                }


                // If it's a thinking message, find the previous one and replace it
                const existingThinkingMessage = conversationDisplay.querySelector('.thinking-message');
                if (isThinking && existingThinkingMessage) {
                    existingThinkingMessage.replaceWith(messageDiv);
                    messageDiv.classList.add('thinking-message'); // Keep track
                } else {
                     // Remove placeholder if it exists
                    const placeholder = conversationDisplay.querySelector('.text-center');
                    if(placeholder) placeholder.remove();
                    conversationDisplay.appendChild(messageDiv);
                }


                // Store history entry (only for non-thinking messages)
                if (!isThinking) {
                    const historyEntry = {
                        sender,
                        message: String(message || ''), // Ensure message is string
                        model,
                        timestamp,
                        audioUrl: null,
                        isLoading: false, // For audio generation
                        isGenerating: false, // For audio generation
                        error: null, // Store audio generation errors
                        element: messageDiv,
                        statusElement: messageDiv.querySelector(`#${statusElementId}`) // Store reference
                    };
                    conversationHistory.push(historyEntry);
                    updatePlaybackControls(); // Update total count
                }

                if (autoScroll.checked && isConversationActive) { // Only auto-scroll during generation
                    conversationDisplay.scrollTop = conversationDisplay.scrollHeight;
                }

                // Enable buttons if needed
                if (conversationHistory.length > 0) {
                    copyBtn.disabled = false;
                    saveBtn.disabled = false;
                    playPauseBtn.disabled = false; // Enable playback controls once there's content
                }

                return messageDiv; // Return the element for potential updates (like streaming)
            }

            function updateMessageContent(messageDiv, newContent, isFinal = false, sender) {
                 const contentWrapper = messageDiv.querySelector('.message-content-wrapper .prose');
                 if (!contentWrapper) return;

                 let processedContent = '';
                  // Ensure content is a string
                 const contentString = String(newContent || '');

                 if (enableMarkdown.checked && sender !== 'User') {
                     try {
                         processedContent = marked.parse(contentString);
                     } catch (e) {
                         console.warn("Markdown parsing error during stream:", e);
                         processedContent = contentString.replace(/\n/g, '<br>');
                     }
                 } else {
                     processedContent = contentString.replace(/\n/g, '<br>');
                 }

                 contentWrapper.innerHTML = processedContent;

                 if (isFinal) {
                     messageDiv.classList.remove('thinking-message');
                 }

                 if (autoScroll.checked && isConversationActive) {
                     conversationDisplay.scrollTop = conversationDisplay.scrollHeight;
                 }
            }

            function updateAudioStatus(index) {
                if (index < 0 || index >= conversationHistory.length) return;
                const entry = conversationHistory[index];
                // User messages don't have status elements
                if (!entry || !entry.statusElement) return;

                let iconHTML;
                if (entry.isGenerating) {
                    iconHTML = `<i class="fa-solid fa-spinner fa-spin text-yellow-500 dark:text-yellow-400" title="Generating audio..."></i>`;
                } else if (entry.audioUrl) {
                    iconHTML = `<i class="fa-solid fa-check-circle text-green-500 dark:text-green-400" title="Audio ready"></i>`;
                } else if (entry.error) { // Add error state
                     iconHTML = `<i class="fa-solid fa-circle-exclamation text-red-500 dark:text-red-400" title="Audio generation failed: ${entry.error}"></i>`;
                } else {
                    iconHTML = `<i class="fa-solid fa-circle-question text-gray-400 dark:text-gray-500" title="Audio not generated"></i>`;
                }
                entry.statusElement.innerHTML = iconHTML;
            }

            function showLoadingIndicator(text = "Generating audio...") {
                if (!loadingIndicator) return;
                const p = loadingIndicator.querySelector('p');
                const div = loadingIndicator.querySelector('div');
                if (p) p.textContent = text;
                // Reset spinner class just in case
                if (div) div.className = 'inline-block animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-blue-500 dark:border-blue-400';
                loadingIndicator.classList.remove('hidden');
            }

            function hideLoadingIndicator() {
                 if (loadingIndicator) loadingIndicator.classList.add('hidden');
            }

            // --- LLM Interaction ---
            async function populatePollinationsModels() {
                // Only populate if not already done
                if (pollutionsModelsPopulated) return;

                try {
                    console.log('Fetching Pollinations models...');
                    const response = await fetch('https://text.pollinations.ai/models');
                    if (!response.ok) throw new Error(`Failed to fetch models: ${response.statusText}`);
                    const models = await response.json();
                    console.log('Received Pollinations models:', models);

                    pollModelGroups.forEach(group => group.innerHTML = ''); // Clear existing

                    // Simple population without health check for speed
                    models.forEach(model => {
                        if (model.name && model.description) { // Basic validation
                            const optionValue = `pollinations:${model.name}`;
                            // Shorten long descriptions
                            const shortDescription = model.description.length > 50 ? model.description.substring(0, 47) + '...' : model.description;
                            const optionText = `${shortDescription} (${model.name})`;
                            const option = document.createElement('option');
                            option.value = optionValue;
                            option.textContent = optionText;
                            option.title = model.description; // Full description on hover
                            pollModelGroups.forEach(group => group.appendChild(option.cloneNode(true)));
                        }
                    });

                    pollutionsModelsPopulated = true;
                    console.log('Pollinations models populated.');

                     // Set default selection if needed (after population)
                    if (currentApiProvider === 'pollinations') {
                         const firstPollinationOption = pollModelGroups[0]?.querySelector('option');
                         if (firstPollinationOption) {
                             bot1Select.value = firstPollinationOption.value;
                             bot2Select.value = firstPollinationOption.value;
                         }
                    }

                } catch (error) {
                    console.error('Error fetching or processing Pollinations models:', error);
                    alert(`Failed to load Pollinations models: ${error.message}. Pollinations provider may be unavailable.`);
                    // Optionally disable the tab
                    pollApiTab.disabled = true;
                     pollApiTab.classList.add('opacity-50', 'cursor-not-allowed', 'text-gray-400');
                     if(currentApiProvider === 'pollinations') {
                         // Try switching back to Puter if possible
                         if(!puterApiTab.disabled) {
                            setTimeout(() => puterApiTab.click(), 0);
                         } else {
                             alert("Both LLM providers seem unavailable.");
                         }
                     }
                }
            }

            async function sendToBot(botNumber) {
                const model = botNumber === 1 ? bot1Select.value : bot2Select.value;
                const systemPrompt = botNumber === 1 ? bot1SystemPrompt.value : bot2SystemPrompt.value;
                const senderName = `Bot ${botNumber}`;
                let fullResponse = '';
                let thinkingMessageDiv = null; // Keep track of the thinking message element
                const finalMessageIndex = conversationHistory.length; // Index where the *final* message will be added

                try {
                    console.log(`sendToBot called for ${senderName} with model ${model}. Expecting index ${finalMessageIndex}.`);

                    // Show thinking state
                    thinkingMessageDiv = appendMessage(senderName, "Thinking...", model, true);

                    // Build message history for context
                    const messages = [{ role: "system", content: systemPrompt }];
                    // Include messages *before* the current thinking one
                    conversationHistory.slice(0, finalMessageIndex).forEach(entry => {
                        const role = entry.sender === 'User' ? 'user' : 'assistant';
                        messages.push({ role: role, content: entry.message });
                    });

                    console.log(`Sending ${messages.length} messages to ${model} via ${currentApiProvider}`);

                    let responseStream;
                    if (currentApiProvider === 'puter') {
                        if (typeof puter === 'undefined') throw new Error("Puter library not loaded.");
                        responseStream = await puter.ai.chat(messages, { model: model, stream: true });
                    } else if (currentApiProvider === 'pollinations') {
                        responseStream = await sendToPollinations(messages, model);
                    } else {
                        throw new Error("Invalid API provider selected.");
                    }

                    console.log(`Stream started for ${senderName}`);
                    for await (const part of responseStream) {
                         if (!isConversationActive) { // Check for interruption during stream
                            console.log(`Stream interrupted for ${senderName}`);
                            throw new Error("Conversation interrupted by user.");
                        }
                        if (part?.text) {
                            fullResponse += part.text;
                            // Update the thinking message content in real-time
                            updateMessageContent(thinkingMessageDiv, fullResponse, false, senderName);
                        }
                    }
                    console.log(`Stream finished for ${senderName}. Full response length: ${fullResponse.length}`);

                    // --- Final Message Update & Audio Trigger ---
                    // Replace the thinking message with the final content
                    const finalMessageDiv = appendMessage(senderName, fullResponse, model); // Add final message
                    if (thinkingMessageDiv && thinkingMessageDiv.parentNode) {
                        thinkingMessageDiv.replaceWith(finalMessageDiv); // Replace placeholder
                    } else {
                        console.warn("Thinking message div not found for replacement.");
                        // If thinking message wasn't found, the final message was already appended.
                        // We still need to ensure the history index is correct.
                        if (conversationHistory.length > finalMessageIndex && conversationHistory[finalMessageIndex].element === finalMessageDiv) {
                             console.log("Final message already appended, proceeding.");
                        } else {
                             console.error("State mismatch after message generation.");
                             throw new Error("Failed to correctly place final message.");
                        }
                    }


                    // --- JIT Audio Trigger ---
                    // Trigger TTS generation *only* for the very first bot message (index 1) immediately.
                    // Subsequent triggers happen during playback.
                    if (finalMessageIndex === 1) { // Index 0 is User, Index 1 is first Bot response
                         console.log(`First bot message (index ${finalMessageIndex}), queueing initial audio.`);
                         queueAudioGeneration(finalMessageIndex);
                    }

                    return fullResponse; // Return the complete text

                } catch (error) {
                    console.error(`Error with ${senderName} (${model}):`, error);
                    // Remove thinking message if it still exists
                    if (thinkingMessageDiv && thinkingMessageDiv.parentNode === conversationDisplay) {
                        thinkingMessageDiv.remove();
                    }
                    // Add error message to conversation display (but not to history for audio generation)
                    appendMessage(senderName, `Error: ${error.message}`, model);
                    isConversationActive = false; // Stop the loop on error
                    updateUIAfterConversationEnd();
                    return null; // Indicate failure
                }
            }

            async function sendToPollinations(messages, model) {
                const baseUrl = 'https://text.pollinations.ai/';
                const pollModel = model.replace('pollinations:', '');

                console.log('Formatted messages for Pollinations:', JSON.stringify(messages));

                const response = await fetch(baseUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: messages,
                        model: pollModel,
                        stream: true,
                        private: true // Keep conversations private
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Pollinations API error (${response.status}): ${errorText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                return {
                    async *[Symbol.asyncIterator]() {
                        try {
                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) {
                                    if (buffer.trim()) { // Process any remaining buffer
                                        if (buffer.trim().startsWith('data:')) {
                                            try {
                                                const jsonData = JSON.parse(buffer.trim().slice(5));
                                                const text = extractTextFromPollinationsChunk(jsonData);
                                                if (text) yield { text };
                                            } catch (e) { console.error('Error parsing final Pollinations chunk:', e, buffer); }
                                        } else {
                                             console.warn("Final buffer part not a data chunk:", buffer);
                                        }
                                    }
                                    break;
                                }

                                buffer += decoder.decode(value, { stream: true });
                                const lines = buffer.split('\n');
                                buffer = lines.pop(); // Keep incomplete line

                                for (const line of lines) {
                                    if (line.trim().startsWith('data:')) {
                                        try {
                                            const jsonData = JSON.parse(line.slice(5).trim());
                                            const text = extractTextFromPollinationsChunk(jsonData);
                                            if (text) yield { text };
                                        } catch (e) {
                                            console.warn('Error parsing Pollinations stream line:', e, line);
                                        }
                                    } else if (line.trim()) {
                                         // console.log("Non-data line from Pollinations:", line); // Can be noisy
                                    }
                                }
                            }
                        } finally {
                             reader.releaseLock(); // Ensure reader lock is released
                        }
                    }
                };
            }

            function extractTextFromPollinationsChunk(jsonData) {
                 // Handle different possible structures based on observation/debugging
                 if (jsonData?.choices?.[0]?.delta?.content) {
                     return jsonData.choices[0].delta.content;
                 }
                 if (jsonData?.response) { // Some models might use this
                     return jsonData.response;
                 }
                 if (typeof jsonData?.content === 'string') { // Direct content
                     return jsonData.content;
                 }
                 // console.log("Unrecognized Pollinations chunk structure:", jsonData);
                 return '';
            }


            // --- Conversation Flow ---
            async function startConversationLoop() {
                const initialInput = userInput.value.trim();
                if (!initialInput) {
                    alert('Please enter a topic or question to start.');
                    return;
                }

                if (isConversationActive) return; // Prevent multiple loops

                console.log('Starting conversation loop');
                isConversationActive = true;
                updateUIAfterConversationStart();

                // Clear placeholder if first message
                if (conversationHistory.length === 0) {
                    conversationDisplay.innerHTML = '';
                }

                // Add user input (index 0)
                appendMessage('User', initialInput);
                updatePlaybackControls();
                // User messages don't get audio.

                userInput.value = ''; // Clear input field

                // Start the bot conversation loop
                while (isConversationActive) {
                     // Check for interruption flag *before* starting next bot turn
                    if (waitingForUserInterruption) {
                        console.log('User interruption requested. Pausing loop.');
                        isConversationActive = false; // Pause the loop
                        interruptionForm.classList.remove('hidden');
                        interruptionInput.focus(); // Focus interruption input
                        break; // Exit loop here
                    }

                    const currentMessageEntry = conversationHistory[conversationHistory.length - 1];
                    if (!currentMessageEntry) {
                         console.error("Loop check: History is empty unexpectedly.");
                         isConversationActive = false;
                         break;
                    }

                    // Determine which bot speaks next
                    const botToSpeak = currentBot;
                    console.log(`Bot ${botToSpeak} turn starting.`);

                    const response = await sendToBot(botToSpeak);

                    if (!isConversationActive || response === null) { // Check if loop was stopped (error or interrupt flag set during sendToBot)
                        console.log('Conversation loop ending due to error or interruption during sendToBot.');
                        break; // Exit loop
                    }

                    // Switch to the other bot for the next turn
                    currentBot = (currentBot === 1) ? 2 : 1;
                    console.log(`Bot ${botToSpeak} turn completed. Next is Bot ${currentBot}.`);


                    // Optional delay between bot turns
                    if (isConversationActive) { // Only delay if not interrupted
                        const delay = Math.random() * 1000 + 500; // 0.5 - 1.5 seconds
                        console.log(`Waiting ${delay.toFixed(0)}ms before next turn...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }

                console.log('Conversation loop finished.');
                // Only update UI if not waiting for user interruption
                if (!waitingForUserInterruption) {
                    updateUIAfterConversationEnd();
                }
            }

            function updateUIAfterConversationStart() {
                startBtn.disabled = true;
                interruptBtn.disabled = false;
                userInput.disabled = true; // Disable main input during conversation
                clearBtn.disabled = true; // Prevent clearing during generation
                // Disable settings changes during conversation
                settingsPanel.querySelectorAll('select, textarea, input[type=checkbox]').forEach(el => el.disabled = true);
                toggleSettings.disabled = true;
                puterApiTab.disabled = true; // Disable API switching
                pollApiTab.disabled = true;
            }

            function updateUIAfterConversationEnd() {
                startBtn.disabled = false;
                interruptBtn.disabled = true;
                userInput.disabled = false;
                clearBtn.disabled = false;
                // Re-enable settings changes
                settingsPanel.querySelectorAll('select, textarea, input[type=checkbox]').forEach(el => el.disabled = false);
                toggleSettings.disabled = false;
                // Re-enable API switching (unless one was disabled due to load failure)
                 if (typeof puter !== 'undefined') puterApiTab.disabled = false;
                 if (pollutionsModelsPopulated || !pollApiTab.disabled) pollApiTab.disabled = false; // Re-enable if models loaded or wasn't disabled initially

                // Ensure playback controls are enabled if there's history
                 updatePlaybackControls();
            }


            // --- TTS Generation & Playback ---

            function queueAudioGeneration(index) {
                if (index < 0 || index >= conversationHistory.length) return;
                const entry = conversationHistory[index];
                // Only queue for bots, and if not already generated or generating/loading
                if (entry.sender !== 'User' && !entry.audioUrl && !entry.isGenerating && !entry.isLoading) {
                     console.log(`Queueing audio generation for index ${index}: "${entry.message.substring(0,30)}..."`);
                    entry.isGenerating = true; // Mark as actively being processed
                    entry.isLoading = true; // Mark as loading (used by playLine)
                    updateAudioStatus(index);
                    audioGenerationQueue.push(index);
                    processAudioQueue(); // Start processing if not already running
                } else {
                     // console.log(`Skipping queue for index ${index} (User=${entry.sender === 'User'}, URL=${!!entry.audioUrl}, Generating=${entry.isGenerating}, Loading=${entry.isLoading})`);
                }
            }

            async function processAudioQueue() {
                if (isProcessingQueue || audioGenerationQueue.length === 0) {
                    return;
                }
                isProcessingQueue = true;
                showLoadingIndicator(); // Show global indicator while processing queue

                while (audioGenerationQueue.length > 0) {
                    const index = audioGenerationQueue.shift(); // Get next index
                    const entry = conversationHistory[index];

                    // Double check entry validity and status before fetching
                    if (!entry || entry.audioUrl || entry.sender === 'User') {
                        console.log(`Skipping fetch for index ${index} in queue processor.`);
                        if(entry) {
                            entry.isLoading = false; // Ensure loading is false if skipped
                            entry.isGenerating = false;
                            updateAudioStatus(index);
                        }
                        continue;
                    }

                    console.log(`Processing audio fetch for index ${index}`);
                    const voice = getVoiceForSpeaker(entry.sender);
                    try {
                        // Add a prefix to encourage conversational tone
                        const textToSpeak = `Say this naturally: ${entry.message}`;
                        const url = `https://text.pollinations.ai/${encodeURIComponent(textToSpeak)}?model=openai-audio&voice=${voice}`;

                        const response = await fetch(url);
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`TTS API error (${response.status}): ${errorText}`);
                        }
                        const blob = await response.blob();
                        entry.audioUrl = URL.createObjectURL(blob);
                        entry.error = null; // Clear previous error if any
                        console.log(`Audio generated successfully for index ${index}`);

                    } catch (error) {
                        console.error(`Error generating audio for index ${index}:`, error);
                        entry.audioUrl = null;
                        entry.error = error.message; // Store error message
                    } finally {
                        entry.isLoading = false; // Mark loading as complete
                        entry.isGenerating = false; // Mark processing as complete
                        updateAudioStatus(index); // Update icon (success, error, or back to question if failed badly)
                        // Small delay before next request to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 250)); // Slightly increased delay
                    }
                }

                isProcessingQueue = false;
                hideLoadingIndicator(); // Hide global indicator when queue is empty
                console.log("Audio generation queue processed.");
            }

            function updatePlaybackControls() {
                // Update play/pause icon
                if (isPlaying) {
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                } else {
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                }

                const totalLines = conversationHistory.length;
                // Disable player if conversation is active OR if there's nothing to play
                const disablePlayer = isConversationActive || totalLines === 0;

                playPauseBtn.disabled = disablePlayer;
                prevBtn.disabled = disablePlayer || currentPlaybackIndex <= 0;
                nextBtn.disabled = disablePlayer || currentPlaybackIndex >= totalLines - 1;

                // Update button styles based on disabled state
                [prevBtn, nextBtn, playPauseBtn].forEach(btn => {
                     if (btn.disabled) btn.classList.add('opacity-50', 'cursor-not-allowed');
                     else btn.classList.remove('opacity-50', 'cursor-not-allowed');
                });


                currentLineDisplay.textContent = totalLines > 0 ? `${currentPlaybackIndex + 1}/${totalLines}` : '0/0';
            }

            function highlightCurrentLine() {
                // Remove highlight from all lines
                conversationHistory.forEach(entry => {
                    if (entry.element) {
                        entry.element.classList.remove('current-playback-line');
                    }
                });

                // Add highlight to current playback line
                if (currentPlaybackIndex >= 0 && currentPlaybackIndex < conversationHistory.length) {
                    const currentEntry = conversationHistory[currentPlaybackIndex];
                    if (currentEntry.element) {
                        currentEntry.element.classList.add('current-playback-line');

                        // Scroll to current line only if not actively generating conversation
                        // and if the element isn't already visible
                        if (!isConversationActive) {
                             const rect = currentEntry.element.getBoundingClientRect();
                             const containerRect = conversationDisplay.getBoundingClientRect();
                             if (rect.top < containerRect.top || rect.bottom > containerRect.bottom) {
                                currentEntry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                             }
                        }
                    }
                }
            }

            async function playLine(index) {
                if (isConversationActive) {
                    console.log("Cannot play audio while conversation is generating.");
                    return;
                }
                if (index < 0 || index >= conversationHistory.length) {
                    console.warn(`playLine called with invalid index: ${index}`);
                    return;
                }

                // Stop current audio if playing
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.removeEventListener('ended', handleAudioEnd); // Clean up listener
                    currentAudio = null; // Important to nullify
                    console.log("Stopped previous audio.");
                }

                currentPlaybackIndex = index;
                updatePlaybackControls();
                highlightCurrentLine();

                const entry = conversationHistory[index];

                // --- Handle User Messages ---
                 if (entry.sender === 'User') {
                     console.log(`Skipping audio playback for User message at index ${index}.`);
                     // If was playing, stop playback state and update controls
                     if (isPlaying) {
                         isPlaying = false;
                         updatePlaybackControls();
                         // Optionally auto-advance to the next line?
                         // setTimeout(() => playNext(), 100);
                     }
                     return;
                }

                // --- Handle Audio Generation & Errors ---
                if (!entry.audioUrl) {
                    if (entry.error) {
                         console.error(`Cannot play line ${index + 1}, audio generation failed previously: ${entry.error}`);
                         isPlaying = false; // Stop playback attempt
                         updatePlaybackControls();
                         return;
                    }
                    // If audio not ready and no error, trigger generation if not already happening
                    if (!entry.isLoading && !entry.isGenerating) {
                        console.log(`Audio for line ${index + 1} not generated, queueing now.`);
                        queueAudioGeneration(index);
                    } else {
                         console.log(`Audio for line ${index + 1} is currently loading/generating.`);
                    }
                    // Indicate loading and return, user needs to press play again or wait
                     isPlaying = false; // Ensure state is paused
                     updatePlaybackControls();
                     updateAudioStatus(index); // Ensure status shows loading/queued
                     // Maybe flash the loading indicator briefly?
                     showLoadingIndicator(`Waiting for audio ${index + 1}...`);
                     setTimeout(hideLoadingIndicator, 1500);
                     return; // Exit play function for now
                }

                // --- Play Audio ---
                console.log(`Playing audio for index ${index}`);
                currentAudio = new Audio(entry.audioUrl);
                currentAudio.addEventListener('ended', handleAudioEnd);
                currentAudio.addEventListener('error', (e) => {
                     console.error(`Audio playback error for index ${index}:`, e);
                     isPlaying = false;
                     updatePlaybackControls();
                     // Maybe mark the entry with a playback error?
                });


                try {
                    await currentAudio.play();
                    isPlaying = true;
                    updatePlaybackControls(); // Update controls *after* successful play start

                    // --- JIT Trigger for NEXT line ---
                    const nextIndex = index + 1;
                    if (nextIndex < conversationHistory.length) {
                        const nextEntry = conversationHistory[nextIndex];
                        // Trigger generation for the *next* line if it's a bot and audio isn't ready/generating/loading
                        if (nextEntry.sender !== 'User' && !nextEntry.audioUrl && !nextEntry.isGenerating && !nextEntry.isLoading) {
                            console.log(`Playback started for ${index}, triggering JIT audio generation for next line (index ${nextIndex})`);
                            queueAudioGeneration(nextIndex);
                        }
                    }
                    // --- End JIT Trigger ---

                } catch (error) {
                    console.error('Error starting audio playback:', error);
                    isPlaying = false;
                    updatePlaybackControls();
                    currentAudio = null; // Clean up failed audio object
                }
            }

             function handleAudioEnd() {
                console.log(`Audio ended for index ${currentPlaybackIndex}`);
                currentAudio = null; // Clear finished audio object
                // Automatically play next line ONLY if isPlaying is still true
                if (isPlaying) {
                    playNext();
                } else {
                    // If paused manually just before ending, ensure UI reflects paused state
                    updatePlaybackControls();
                    highlightCurrentLine(); // Keep highlight on the finished line if paused
                }
            }

            function togglePlayPause() {
                if (isConversationActive) return; // Don't allow during generation

                if (isPlaying) {
                    // Pause
                    if (currentAudio) {
                        currentAudio.pause();
                    }
                    isPlaying = false;
                    console.log("Playback paused.");
                } else {
                    // Play or Resume
                    if (currentAudio && currentAudio.paused && !currentAudio.ended) {
                        // Resume paused audio
                        currentAudio.play().then(() => {
                            isPlaying = true;
                            console.log("Playback resumed.");
                            updatePlaybackControls();
                            // Trigger JIT for next line upon resuming as well
                             const nextIndex = currentPlaybackIndex + 1;
                             if (nextIndex < conversationHistory.length) {
                                 const nextEntry = conversationHistory[nextIndex];
                                 if (nextEntry.sender !== 'User' && !nextEntry.audioUrl && !nextEntry.isGenerating && !nextEntry.isLoading) {
                                     console.log(`Playback resumed for ${currentPlaybackIndex}, triggering JIT for next line (${nextIndex})`);
                                     queueAudioGeneration(nextIndex);
                                 }
                             }
                        }).catch(err => {
                            console.error('Error resuming audio:', err);
                            isPlaying = false; // Ensure state reflects failure
                            updatePlaybackControls();
                        });

                    } else {
                        // Start playing from the current index (or index 0 if nothing selected)
                        const indexToPlay = (currentPlaybackIndex >= 0 && currentPlaybackIndex < conversationHistory.length) ? currentPlaybackIndex : 0;
                        console.log(`Starting playback from index ${indexToPlay}`);
                        playLine(indexToPlay); // This will set isPlaying = true on success
                    }
                }
                // Update controls immediately for pause, or after promise for play/resume
                if (!isPlaying) updatePlaybackControls();
            }

            function playNext() {
                if (isConversationActive) return;
                if (currentPlaybackIndex < conversationHistory.length - 1) {
                    playLine(currentPlaybackIndex + 1);
                } else {
                    // Reached end of conversation
                    console.log("Reached end of conversation.");
                    if (isPlaying) { // If it was playing the last message
                         isPlaying = false; // Stop playback state
                         if (currentAudio) {
                             currentAudio.pause(); // Ensure last audio is stopped
                             currentAudio.removeEventListener('ended', handleAudioEnd);
                             currentAudio = null;
                         }
                         updatePlaybackControls();
                         highlightCurrentLine(); // Keep highlight on last line
                    }
                }
            }

            function playPrevious() {
                if (isConversationActive) return;
                if (currentPlaybackIndex > 0) {
                    playLine(currentPlaybackIndex - 1);
                }
            }

            // --- Other UI & Utility ---

            function clearConversation() {
                console.log('User clicked clear button');
                if (conversationHistory.length > 0 && !confirm('Are you sure you want to clear the current conversation and stop playback?')) {
                    return;
                }

                // Stop any active processes
                isConversationActive = false; // Ensure generation stops
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.removeEventListener('ended', handleAudioEnd);
                }
                isPlaying = false;
                currentAudio = null;
                audioGenerationQueue = []; // Clear generation queue
                isProcessingQueue = false; // Reset queue processing flag

                // Revoke old audio URLs
                conversationHistory.forEach(entry => {
                    if (entry.audioUrl) {
                        try { URL.revokeObjectURL(entry.audioUrl); } catch(e) { console.warn("Error revoking URL:", e); }
                    }
                });

                // Reset state
                conversationHistory = [];
                currentPlaybackIndex = 0;
                currentBot = 1; // Reset starting bot

                // Reset UI
                conversationDisplay.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400">Start a conversation to see messages here</div>';
                interruptionForm.classList.add('hidden');
                userInput.value = '';
                interruptionInput.value = '';
                copyBtn.disabled = true;
                saveBtn.disabled = true;
                updatePlaybackControls(); // Reset player controls
                updateUIAfterConversationEnd(); // Reset conversation controls
                hideLoadingIndicator(); // Ensure loading indicator is hidden
            }

            function convertToMarkdown() {
                let markdown = "# Slopcaster AI Conversation\n\n";
                markdown += `*LLM Provider: ${currentApiProvider}*\n`;
                markdown += `*Bot 1 Model: ${bot1Select.options[bot1Select.selectedIndex].text}*\n`;
                markdown += `*Bot 2 Model: ${bot2Select.options[bot2Select.selectedIndex].text}*\n\n`;
                markdown += "---\n\n";

                conversationHistory.forEach(entry => {
                    const timestamp = entry.timestamp && enableTimestamps.checked ? ` - ${entry.timestamp}` : '';
                    const model = entry.model ? ` (${entry.model})` : '';
                    markdown += `## ${entry.sender}${model}${timestamp}\n\n`;
                    markdown += `${entry.message}\n\n`;
                });
                return markdown;
            }

            function copyToClipboard() {
                const markdown = convertToMarkdown();
                navigator.clipboard.writeText(markdown)
                    .then(() => {
                        const originalHTML = copyBtn.innerHTML;
                        copyBtn.innerHTML = `
                            <span class="flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>
                                Copied!
                            </span>`;
                        copyBtn.disabled = true;
                        setTimeout(() => {
                             copyBtn.innerHTML = originalHTML;
                             copyBtn.disabled = conversationHistory.length === 0;
                        }, 2000);
                    })
                    .catch(err => alert('Failed to copy: ' + err));
            }

            function saveConversation(format) {
                let filename = conversationName.value.trim() || "ai-conversation";
                let content;
                let mimeType;

                if (format === 'markdown') {
                    content = convertToMarkdown();
                    filename = filename.endsWith('.md') ? filename : filename + '.md';
                    mimeType = 'text/markdown;charset=utf-8';
                } else { // JSON
                    // Create a serializable version without DOM elements
                    const serializableHistory = conversationHistory.map(entry => ({
                        sender: entry.sender,
                        message: entry.message,
                        model: entry.model,
                        timestamp: entry.timestamp,
                        // Optionally include audio status info if desired, but not the URL itself
                        audioGenerated: !!entry.audioUrl,
                        audioError: entry.error || null
                    }));
                    content = JSON.stringify({
                        provider: currentApiProvider,
                        bot1Model: bot1Select.value,
                        bot2Model: bot2Select.value,
                        bot1SystemPrompt: bot1SystemPrompt.value,
                        bot2SystemPrompt: bot2SystemPrompt.value,
                        history: serializableHistory
                    }, null, 2);
                    filename = filename.endsWith('.json') ? filename : filename + '.json';
                    mimeType = 'application/json;charset=utf-8';
                }

                try {
                    const blob = new Blob([content], { type: mimeType });
                    saveAs(blob, filename);
                } catch (e) {
                     console.error("Save failed:", e);
                     alert("Failed to save file. See console for details.");
                } finally {
                    saveDialog.classList.add('hidden');
                }
            }


            // --- Event Listeners ---
            // LLM Controls
            startBtn.addEventListener('click', startConversationLoop);
            userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !startBtn.disabled) {
                    e.preventDefault();
                    startBtn.click();
                }
            });
            clearBtn.addEventListener('click', clearConversation);
            interruptBtn.addEventListener('click', () => {
                if (!isConversationActive) return;
                console.log('User clicked interrupt button');
                waitingForUserInterruption = true; // Set flag
                // isConversationActive = false; // Let the loop check the flag
                interruptBtn.disabled = true; // Disable until resumed or cleared
                console.log("Interrupt requested, waiting for current bot to finish or next loop check...");
            });

            // Interruption Form
            cancelInterruption.addEventListener('click', () => {
                console.log('User cancelled interruption');
                waitingForUserInterruption = false;
                interruptionForm.classList.add('hidden');
                // Reset controls as if conversation ended
                updateUIAfterConversationEnd();
            });
            submitInterruption.addEventListener('click', async () => {
                const interruptionMessage = interruptionInput.value.trim();
                if (!interruptionMessage) {
                    alert('Please enter your interruption message.');
                    return;
                }

                console.log("Submitting user interruption");
                interruptionForm.classList.add('hidden');
                interruptionInput.value = '';

                // Add user message (index N)
                appendMessage('User', interruptionMessage);
                updatePlaybackControls();
                // No audio for user message

                // Resume conversation loop
                waitingForUserInterruption = false;
                isConversationActive = true; // Allow loop to continue
                updateUIAfterConversationStart(); // Re-disable input etc.
                // The loop will pick up from where it left off, considering the new user message
                startConversationLoop(); // Re-enter the loop logic check
            });
             interruptionInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    submitInterruption.click();
                }
            });


            // Settings
            toggleSettings.addEventListener('click', () => settingsPanel.classList.toggle('hidden'));
            puterApiTab.addEventListener('click', () => {
                if (currentApiProvider === 'puter' || puterApiTab.disabled) return;
                currentApiProvider = 'puter';
                puterApiTab.classList.add('api-tab-active');
                pollApiTab.classList.remove('api-tab-active');
                puterModelGroups.forEach(group => group.style.display = '');
                pollModelGroups.forEach(group => group.style.display = 'none');
                // Reset selection to first Puter model
                const firstPuterOption = puterModelGroups[0]?.querySelector('option');
                if (firstPuterOption) {
                    bot1Select.value = firstPuterOption.value;
                    bot2Select.value = firstPuterOption.value;
                }
            });
            pollApiTab.addEventListener('click', async () => {
                 if (currentApiProvider === 'pollinations' || pollApiTab.disabled) return;
                 currentApiProvider = 'pollinations';
                 pollApiTab.classList.add('api-tab-active');
                 puterApiTab.classList.remove('api-tab-active');
                 puterModelGroups.forEach(group => group.style.display = 'none');
                 pollModelGroups.forEach(group => group.style.display = '');

                 await populatePollinationsModels(); // Fetch/populate if needed

                 // Reset selection to first Pollinations model (if available)
                 const firstPollinationOption = pollModelGroups[0]?.querySelector('option');
                 if (firstPollinationOption) {
                     bot1Select.value = firstPollinationOption.value;
                     bot2Select.value = firstPollinationOption.value;
                 } else {
                      console.warn("No Pollinations models available to select.");
                      // Optionally switch back or show error
                 }
            });

            // Appearance/Behavior Settings (Redraw on change)
            [enableMarkdown, enableAvatar, enableTimestamps].forEach(el => {
                el.addEventListener('change', () => {
                    if (conversationHistory.length > 0) {
                        console.log("Redrawing conversation due to setting change...");
                        const currentScrollTop = conversationDisplay.scrollTop; // Preserve scroll position
                        const wasPlaying = isPlaying; // Preserve playback state
                        const currentAudioTime = currentAudio ? currentAudio.currentTime : 0;

                        // Stop current audio before redraw
                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio.removeEventListener('ended', handleAudioEnd);
                            currentAudio = null;
                        }
                        isPlaying = false;

                        conversationDisplay.innerHTML = ''; // Clear display
                        const oldHistory = [...conversationHistory]; // Copy old history
                        conversationHistory = []; // Reset current history

                        oldHistory.forEach((entry, index) => {
                            // Re-append using the new settings
                            appendMessage(entry.sender, entry.message, entry.model);
                            // Restore audio state
                            const newEntry = conversationHistory[index]; // Get the newly created entry
                            if (newEntry) {
                                newEntry.audioUrl = entry.audioUrl; // Keep existing URL
                                newEntry.isLoading = entry.isLoading;
                                newEntry.isGenerating = entry.isGenerating;
                                newEntry.error = entry.error;
                                updateAudioStatus(index); // Update icon based on restored state
                            } else {
                                 console.error(`State mismatch during redraw at index ${index}`);
                            }
                        });

                        highlightCurrentLine(); // Re-highlight
                        conversationDisplay.scrollTop = currentScrollTop; // Restore scroll
                        updatePlaybackControls(); // Update player buttons

                        // Optionally resume playback (might be slightly off due to redraw time)
                        // if (wasPlaying && currentPlaybackIndex < conversationHistory.length) {
                        //     playLine(currentPlaybackIndex);
                        //     // Attempt to seek? Risky.
                        // }
                    }
                });
            });

            // Voice Selection (Affects future generation)
            [userVoiceSelect, bot1VoiceSelect, bot2VoiceSelect].forEach(select => {
                select.addEventListener('change', () => {
                    console.log("Voice selection changed. Future TTS will use new voices.");
                    // Invalidate existing audio? Could add a button for this.
                    // For now, only new audio uses the new voice.
                });
            });


            // Player Controls
            playPauseBtn.addEventListener('click', togglePlayPause);
            prevBtn.addEventListener('click', playPrevious);
            nextBtn.addEventListener('click', playNext);

            // Copy/Save
            copyBtn.addEventListener('click', copyToClipboard);
            saveBtn.addEventListener('click', () => {
                const date = new Date();
                const defaultName = `slopcaster-${date.toISOString().split('T')[0]}`;
                conversationName.value = defaultName;
                saveDialog.classList.remove('hidden');
            });
            saveMarkdown.addEventListener('click', () => saveConversation('markdown'));
            saveJson.addEventListener('click', () => saveConversation('json'));
            cancelSave.addEventListener('click', () => saveDialog.classList.add('hidden'));
            saveDialog.addEventListener('click', (e) => { // Close on backdrop click
                if (e.target === saveDialog) saveDialog.classList.add('hidden');
            });

            // Dark Mode
            darkModeToggle.addEventListener('click', toggleDarkMode);

             // Keyboard Shortcuts
            document.addEventListener('keydown', (e) => {
                const activeTag = document.activeElement.tagName;
                const isInputFocused = activeTag === 'INPUT' || activeTag === 'TEXTAREA';

                // Spacebar for Play/Pause (if not focused on input/textarea)
                if (e.key === ' ' && !isInputFocused && !playPauseBtn.disabled) {
                    e.preventDefault();
                    togglePlayPause();
                }
                // Left Arrow for Previous
                if (e.key === 'ArrowLeft' && !isInputFocused && !prevBtn.disabled) {
                    e.preventDefault();
                    playPrevious();
                }
                // Right Arrow for Next
                if (e.key === 'ArrowRight' && !isInputFocused && !nextBtn.disabled) {
                    e.preventDefault();
                    playNext();
                }
                 // Cmd/Ctrl+C to copy
                if ((e.metaKey || e.ctrlKey) && e.key === 'c' && !copyBtn.disabled && window.getSelection().toString() === '') { // Only if not selecting text
                    e.preventDefault();
                    copyToClipboard();
                }
                // Cmd/Ctrl+S to save
                if ((e.metaKey || e.ctrlKey) && e.key === 's' && !saveBtn.disabled) {
                    e.preventDefault();
                    saveBtn.click();
                }
                // Escape to close dialogs or settings
                if (e.key === 'Escape') {
                    if (!saveDialog.classList.contains('hidden')) {
                        saveDialog.classList.add('hidden');
                    } else if (!interruptionForm.classList.contains('hidden')) {
                        cancelInterruption.click(); // Use cancel logic
                    } else if (!settingsPanel.classList.contains('hidden')) {
                        settingsPanel.classList.add('hidden');
                    }
                }
            });

        }); // End DOMContentLoaded
    </script>
</body>
</html>